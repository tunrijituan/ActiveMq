# ActiveMq
## 之前在使用ActiveMQ消息中间件进行分流时遇到了一些问题，特意对此做一个记录，方便以后再次出现这类问题进行处理;
### 1.消费者在线上执行代码时有时候成功，有时候失败；但是在线下调试过程是完全正确的;
* 检查方向：打开自己设置的IP+:8161/admin;本地默认打开localhost:8161/admin；输入账号和密码，初始账号和密码均为admin，
  打开后查看消费者个数是否是自己设置的个数，如果大于自己代码中设置的个数，则考虑是否在远程服务器上已经有了相关设置，但是远程的代码并不是最新的；
  这里要考虑到的是线上线下工程代码设置是否不一致问题
* 解决方案：删除远程服务器上的工程，即可搞定时而成功，时而失败的方法；
### 2.发送消息之后，开启2个消费者去处理消息。会发现一个消费者处理了所有的消息，另一个消费者根本没收到消息；
* 这种问题出现的概率还是挺大的，经常看到博客上有人问这个问题。其实这个问题出现的原因是由于ActiveMQ的prefetch机制；
  当消费者去获取消息时，不会一条一条去获取，而是一次性获取一批，默认是1000条。这些预获取的消息，在还没确认消费之前，在管理控制台还是可以看见这些消息的，
  但是不会再分配给其他消费者，此时这些消息的状态应该算作“已分配未消费”，如果消息最后被消费，则会在服务器端被删除，如果消费者崩溃，
  则这些消息会被重新分配给新的消费者。但是如果消费者既不消费确认，又不崩溃，那这些消息就永远躺在消费者的缓存区里无法处理。
  更通常的情况是，消费这些消息非常耗时，你开了10个消费者去处理，结果发现只有一台机器慢吞吞地在处理，另外9台啥事不干。
* 解决方案：暴力法->将prefetch设为1，每次处理1条消息，处理完再去取，这样其实也慢不了多少。
### Attention:一般情况下我们在消息处理失败后，是不希望消息被服务器删除，而是交由其他消费者处理或重试，此时应该关闭AUTO_ACKNOWLEDGE，将ack交由程序自己处理。
  当然如果一定要使用AUTO_ACKNOWLEDGE，activemq本身也是支持的，可采用如下两种方法：一种是调用consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。
  这种情况下，消息返回给方法调用者之后就自动被确认了。另一种方法是采用listener回调函数，在有消息到达时，会调用listener接口的onMessage方法。
  在这种情况下，在onMessage方法执行完毕后，消息才会被确认，此时只要在方法中抛出异常，该消息就不会被确认。
  那么问题来了，如果一条消息不能被处理，会被退回服务器重新分配，如果只有一个消费者，该消息又会重新被获取，重新抛异常。
  就算有多个消费者，往往在一个服务器上不能处理的消息，在另外的服务器上依然不能被处理。难道就这么退回--获取--报错死循环，当然不是
  在重试6次后，ActiveMQ将会把消息丢到死信队列里。如果你的消息不见了，可以去ActiveMQ.DLQ里找找；
